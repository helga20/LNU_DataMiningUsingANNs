%Формування одношарової статичної лінійної мережі з двома входами
%і нульовим параметром швидкості налаштування
net = newlin([-1 1;-1 1],1, 0, 0);

% Масив комірок векторів входу
P = {[-1; 1] [-1/3; 1/4] [1/2; 0] [1/6; 2/3]};
T = {-1 -5/12 1 1}; % Масив комірок цільових векторів
P1 = [P{:}]; T1=[T{:}]; % Перехід від масиву комірок до масиву double

% Вивід P1
fprintf('P1 = \n');
for i = 1:size(P1, 2)
    fprintf('%0.5f ', P1(:, i));
    fprintf('\n');
end

% Вивід T1
fprintf('T1 = ');
fprintf('%0.5f ', T1);
fprintf('\n');
disp('*****************************************************');

net.IW{1} = [0 0]; % Присвоєння початкових ваг
net.b{1} = 0; % Присвоєння початкового зміщенн

% Послідовна адаптація мережі з входами P та цілями T
[net1, a, e] = adapt (net, P, T);
% net1-нова мережа, a-вихід, e-помилка навчання
% net1.IW{1, 1}, a, e
fprintf('ans ='); disp(net1.IW{1, 1}), fprintf('a ='); disp(a), fprintf('e =');disp(e)
disp('*****************************************************');

net.IW{1} = [0 0]; % Присвоєння початкових ваг
net.b{1} = 0; % Присвоєння початкового зміщення
net.inputWeights{1,1}.learnParam.lr = 0.2;
net.biases{1,1}.learnParam.lr = 0;

[net1, a, e] = adapt (net, P, T);
% net1.IW{1, 1}, a, e
fprintf('ans ='); disp(net1.IW{1, 1}), fprintf('a ='); disp(a), fprintf('e =');disp(e)
disp('*****************************************************');

% Послідовна адаптація мережі з входами P та цілями T за 30 циклів
net = newlin([-1 1;-1 1],1, 0, 0);
net.IW{1} = [0 0]; % Присвоєння початкових ваг
net.b{1} = 0; % Присвоєння початкового зміщення

net.inputWeights{1,1}.learnParam.lr = 0.2;
net.biases{1,1}.learnParam.lr = 0;
P = {[-1; 1] [-1/3; 1/4] [1/2; 0] [1/6; 2/3]}; % Масив векторів входу
T = {-1 -5/12 1 1}; % Масив цільових векторів

a = cell(1, 30); % Ініціалізуємо комірку для зберігання виходів на кожному кроці
e = cell(1, 30); % Ініціалізуємо комірку для зберігання помилок на кожному кроці

W = zeros(30, size(net.IW{1,1}, 2)); % Ініціалізуємо масив для зберігання ваг на кожному кроці

for i = 1:30
    [net, a{i}, e{i}] = adapt(net, P, T);
    W(i, :) = net.IW{1,1};
end

% Розрахунок середньоквадратичної помилки адаптації
mse_value = mse(cell2mat(e{30}));
disp(['ans = ', num2str(mse_value)]);
disp('*****************************************************');

% Вивід ваг після 30 циклів
disp(['ans = ', num2str(W(30, :))]);
disp('*****************************************************');

% Вивід виходів на останньому кроці
disp(['ans = ', num2str(cell2mat(a{30}))]);
disp('*****************************************************');

% Вивід виходів на останньому кроці
disp(['ans = ', num2str(cell2mat(e{30}))]);
disp('*****************************************************');

% Графіки залежності значень виходів мережі та вагових коеф. залежно від к-сті ітерацій
subplot(3,1,1)
for i=1:30
    a{i}=(cell2mat(a{i}))';
end

%Графіки залежності значень виходів мережі та вагових коеф. залежно від к-сті ітерацій
a=cell2mat(a);
a=cat(2,[0;0;0;0],a);
plot(0:30,a,'k') % Рис 19,a
xlabel(''), ylabel('Виходи a(i)'),grid
subplot(3,1,2)
plot(0:30,[[0 0]; W],'k') % Рис 19,б
xlabel(''), ylabel('Вага входів w(i)'),grid
subplot(3,1,3)
E = zeros(1, 30); % Попереднє вирівнювання для зберігання значень MSE
for i=1:30
    E(i) = mse(e{i}); 
end
semilogy(1:30, E,'+k') % Мал. 19,в
xlabel('Цикли'), ylabel('Помилка'),grid