% Груповий спосіб адаптації мережі з входами P та цілями T
net3 = newlin([-1 1;-1 1],1, 0, 0.2);
net3.IW{1} = [0 0]; % Присвоєння початкових ваг
net3.b{1} = 0; % Присвоєння початкового зміщення
net3.inputWeights{1,1}.learnParam.lr = 0.2;

P = [-1 -1/3 1/2 1/6; 1 1/4 0 2/3];
T = [-1 -5/12 1 1];
EE = 10; i=1;

a = cell(1, 100); % Ініціалізуємо комірку для збереження виходів на кожному кроці
e = cell(1, 100); % Ініціалізуємо комірку для збереження помилок на кожному кроці

% Попереднє виділення масивів ee та W
ee = zeros(1, 100); % Попереднє виділення масиву ee
W = zeros(100, size(net3.IW{1,1}, 2)); % Попереднє виділення масиву W

while EE > 0.0017176
    [net3, a{i}, e{i}, pf] = adapt(net3, P, T);
    W(i,:) = net3.IW{1,1};
    EE = mse(e{i});
    ee(i) = EE;
    i = i + 1;
end

disp(['ans = ', num2str(W(63,:))]);
disp('*****************************************************');

disp(['ans = ', num2str(cell2mat(a(63)))]);
disp('*****************************************************');

disp(['EE = ', num2str(mse(e{63}))]);
disp('*****************************************************');

disp(['ans = ', num2str(mse(e{1}))]);
disp('*****************************************************');

% Процедура адаптації виходів та параметрів нейронної мережі
subplot(3,1,1)
plot(0:63,[zeros(1,4); cell2mat(a(1:63)')],'k') % Рис.20,a
xlabel(''), ylabel('Виходи a(i)'),grid

subplot(3,1,2)
plot(0:63,[[zeros(1,2); W(1:63,:)]],'k') % Рис.20,б
xlabel(''), ylabel('Вага входів w(i)'),grid

subplot(3,1,3)
semilogy(1:63, ee(1:63),'+k') % Рис.20,в
xlabel('Цикли'), ylabel('Помилка'),grid
